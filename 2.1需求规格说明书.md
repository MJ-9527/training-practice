# 需求规格说明书

# 版本记录

版本	日期	     作者	        说明
1.0	    2025.12.30	刘禹涛，张志廣	依据选题要求以及模板要求分析编写



# 目录

1.引言
    
2.总体描述
    
3.用户需求
    
4.系统功能需求
    
5.非功能需求
    
6.数据需求
    
7.外部接口需求 
    
8.运行与部署约束
    
9.附录


##  1.引言

### 1.1目的

本文档定义《Go高并发文件批量处理工具》（以下简称 FileGo ）的软件需求，用于：  
a 指导项目团队进行概要设计、实现与测试；  
b 作为验收与交付的基准；  
c 为后续维护、扩展提供依据。

### 1.2 项目背景

传统脚本（bash、Python）在大目录下串行处理文件时 I/O 利用率低、耗时长。Go 原生 goroutine/channel 可低成本启动数万并发单元，特别适合批量文件 I/O 场景。本项目旨在开发一款跨平台命令行工具，通过 Worker-Pool 并发模型，对指定目录下的文件执行复制、重命名、加前后缀、MD5 校验等操作，并实时展示进度与结果。

### 1.3 目标与范围

**目标**：构建轻量级、高性能、易扩展的文件批量处理引擎，单盘 8 线程下比串行脚本提速 ≥ 5 倍，99 % 任务在 100 ms 内完成。

**范围**：

-   包含：并发调度、文件操作、进度/日志、错误处理、命令行参数解析。
    
-   不包含：GUI、网络传输、持久化数据库、加密算法（仅 MD5 校验）。

### 1.4 定义与缩略语

Goroutine：Go 轻量级线程

Channel：Go CSP 通信管道

Worker-Pool：固定数量工作者循环读取任务 Channel 的模式

Task：一个待处理的文件单元

MD5：消息摘要算法，用于完整性校验

### 1.5 参考资料
-   Go 官方文档 1.23
    
-   《Rust-Web服务器需求规格概要说明书》 2024
    
-   《东莞市科协综合业务提升项目需求规划说明书》V1.1
    
-   GB/T 9385-2008 计算机软件需求规格说明规范


## 2 总体描述

您可以通过单击菜单中的 **导入/导出** 来导出当前文件。您可以选择将文件导出为纯 Markdown、使用 Handlebars 模板的 HTML 或 PDF。

### 2.1 产品视角

FileGo 为独立命令行实用程序，采用 Go1.23 + 标准库实现，依赖第三方进度条库 github.com/cheggaaa/pb/v3（MIT）。整体位于用户态，直接调用宿主机文件系统 API。

### 2.2 产品功能概览

#### 2.21 并发调度子系统

1. 采用固定大小 Worker-Pool 模式，主 goroutine 扫描目录后把 Task 结构写入缓冲 Channel，Workers 循环读取并执行。

2. 支持运行时参数 `-workers`（1-200），默认取 `runtime.NumCPU()*2`。

3. 优雅退出：捕获 SIGINT/SIGTERM 后停止分发，等待已派发任务完成，超时 5s 强制退出。

#### 2.22 文件操作子系统（Operator）

1. copy：递归复制目录树，保持权限与修改时间；目标文件存在时自动加后缀 `_1`、`_2`…。

2. rename：使用 Go Template 语法，可按“文件名+时间戳”等规则批量重命名。 

3. prefix/suffix：对纯文件名部分添加前后缀，长度校验 ≤200 字符，防止文件名过长错误。

4. md5：为每个文件并行计算 MD5，生成 `<file>.md5` 文本，格式兼容 `md5sum -c`。

#### 2.23 进度与日志子系统

1. 实时进度条：总任务数、已完成、失败数、速度 (files/s)、ETA，刷新周期 ≤200 ms。

2. 分级日志：ERROR/WARN/INFO/DEBUG，同时写控制台与 `filego.log`，10 MB 轮转保留 7 天。

3. 可输出机器友好的 JSON 行日志，供 CI/CD 解析。

#### 2.24 错误处理与重试

1. 任何 Task panic 仅影响本 Worker，由 `defer recover` 捕获并记入错误 Channel。

 2. I/O 类错误默认重试 3 次，指数退避 10 ms→20 ms→40 ms；超出后把 TaskID、路径、错误码写入 `filego-error.log`，支持 `--resume` 断点续作。

#### 2.25 命令行接口（CLI）

1. 子命令模式：`copy | rename | md5 | prefix | suffix`，各子命令独享参数集。

 2. 必填参数缺失时给出示例并返回码 1；`-h/--help` 自动生成帮助；`-v/--version` 显示版本与编译信息。
 
3. 支持 `-c filego.toml` 配置文件，命令行参数优先级高于文件。


## 3 用户需求

### 3.1 高性能

UR-1 工具应支持用户通过 `-workers` 参数在 1~200 之间自由设定并发度；在 4 核 8 线程笔记本、SSD 环境下，使用 50 个 Worker 处理 1 万个 10 MB 文件时，总耗时不得超过 30 秒，相比系统串行 `cp` 命令提速不低于 5 倍；CPU 利用率应稳定在 70% 以上，避免空转或过载。

UR-2 单文件处理延迟（从 Task 进入 Channel 到 Worker 完成 close）P95 ≤ 100 ms；对于大于 100 MB 的大文件，采用 16 MB 分块并发复制，块内失败可局部重试，确保延迟可控。

UR-3 内存占用随 Worker 数量线性增长，100 Worker 峰值 RSS ≤ 200 MB；当 Channel 缓冲写满时，主扫描线程须在 100 ms 内感知并降级为“同步直写”，防止内存无限膨胀。

### 3.2 可靠性

UR-4 任意单个任务崩溃（panic、I/O 致命错误）不得影响其他 Worker 继续执行；系统通过 `defer recover` 捕获异常，记录 ERROR 日志后可立即重启该 Worker，并发度始终保持设定值。

UR-5 遇到可重试错误（临时锁、磁盘繁忙）默认自动重试 3 次，退避策略 10 ms→20 ms→40 ms；重试仍失败时，把 TaskID、文件路径、错误码、重试次数写入 `filego-error.log`，并继续处理后续任务。

UR-6 支持 `--resume` 断点续作：异常退出后再次启动，工具能读取上一次成功的 TaskID 列表，自动跳过已完成的文件，仅重跑失败或未完成的部分，减少重复工作时间。

### 3.3 易用性

UR-7 单条命令即可完成常见批量操作，无需用户编写脚本；例如“给日志加日期后缀”仅需：
filego rename -src /var/log -rule '{{.Name}}_{{.ModTime "20060102"}}'

帮助系统会在缺少必填参数时给出示例并返回码 1。

UR-8 实时进度条显示总任务数、已完成、失败、速度 (files/s)、ETA，刷新周期 ≤ 200 ms；非 TTY 环境（CI、cron）自动退化为 JSON 行输出，方便下游解析。

UR-9 日志分级 `-v`（info） `-vv`（debug），同时写控制台与 `filego.log`；ERROR 级别带红色高亮，DEBUG 级别额外输出 Channel 长度、内存占用、系统 FD 数，帮助用户快速定位性能瓶颈。

### 3.4 可移植性

UR-10 一份静态编译二进制可在 Windows 10+/Linux kernel 3.10+/macOS 11+ 运行，不依赖 CGO；交叉编译命令：
GOOS=windows GOARCH=amd64 go build -ldflags="-s -w"

UPX 压缩后体积 ≤ 8 MB，方便随身携带或在容器内使用。

UR-11 配置文件采用 TOML 格式，路径可通过 `-c` 指定；同一配置文件中可定义 `[common]` `[copy]` `[md5]` 等多段，命令行参数始终优先，确保在不同环境（开发、测试、生产）下快速切换。


## 4 系统功能需求

### 4.1 并发调度模块

#### 4.1.1 Worker-Pool 子功能

FS-01 启动阶段根据 `-workers` 参数创建固定数量的 Worker goroutine，数量范围 1–200，默认值为 CPU 核心数 × 2。每个 Worker 生命周期与主进程相同，内部通过 `for range` 持续读取任务 Channel；若某个 Worker 因 panic 异常退出，Monitor goroutine 会在 1 秒内重新拉起新 Worker，并向日志子系统发送一条包含 WorkerID 与堆栈的 ERROR 记录，确保并发度始终维持在设定值。

FS-02 任务 Channel 的缓冲长度通过 `-chanbuf` 显式可控，最小 1，最大 10000，默认取 2×workers。当缓冲区写满时，主扫描线程将被阻塞；阻塞时间超过 100 ms 即触发降级策略：临时把当前任务改为同步直写模式，并在 DEBUG 日志中记录“Channel back-pressure, switch to sync”提示，防止内存无限增长。

FS-03 优雅退出流程分为三阶段：①主进程收到 SIGINT/SIGTERM 后，首先设置原子变量 `shuttingDown=1`，停止目录扫描；②等待已派发任务完成，超时 5 秒强制调用 `context.Cancel`；③退出前打印一行可解析的 Summary，格式为 `Summary: Success X / Failed Y / Elapsed T(s)`，便于上游脚本根据返回码与摘要行做二次判断。

#### 4.1.2 任务分发

FS-04 主扫描线程将文件路径封装为 Task 结构（含 SrcPath、DstPath、OpType、RetryCount），写入 Channel；当 Channel 写阻塞超过 100 ms 时自动降级为“同步直写”模式并输出 DEBUG 日志，防止内存无限增长。

#### 4.1.3 结果收集

FS-05 使用 errs / results 两个 Channel 收集失败与成功事件；主 goroutine 按批次（每 100 条或 1 s）聚合写日志，降低磁盘 IOPS；批次内按 TaskID 排序，方便与后续审计对齐。

### 4.2 文件操作模块

#### 4.2.1 批量复制

FS-06 支持 `-op copy -src /data -dst /backup`；保持原目录树及权限位（Windows 下仅保持只写/只读）；如目标文件已存在，自动重命名后缀 `_1`、`_2`…直到无冲突；复制过程使用 `io.CopyBuffer` + 32 KB 共享缓冲池，减少 GC 压力；大文件（≥ 100 MB）采用分块（16 MB）并发复制，块内失败可局部重试。

#### 4.2.2 批量重命名

FS-07 支持 `-op rename -rule '{{.Name}}_{{.ModTime "20060102"}}'` Go template 语法；内置字段 `Name`、`Dir`、`Size`、`ModTime`、`MD5`（前 8 位），用户可自由组合；模板解析失败给出详细错误行列号；重命名前进行“dry-run”预检，列出新旧名称对照表，用户确认后再真正执行。

#### 4.2.3 前后缀添加

FS-08 `-prefix PRE_ -suffix _SUF`；只对纯文件名部分生效，目录路径保持不变；长度校验 ≤ 200 字符，超长立即跳过并记录 WARN；支持 Unicode normalization（NFKC），确保中文、Emoji 不会异常截断；若添加后文件名冲突，自动追加 `_<序号>`。

#### 4.2.4 MD5 校验

FS-09 生成 `<原文件名>.md5` 文本文件，每行格式 `MD5_HEX *文件名` 符合 GNU md5sum 规范；读取使用 32 KB 缓冲，单 goroutine 限速 500 MB/s（NVMe 实测）防止占满 CPU；支持并行计算：按文件大小降序调度，大文件优先使用更多 Worker；校验失败输出差异报告，包括文件大小、实际 MD5、期望 MD5。

### 4.3 进度与日志模块

#### 4.3.1 实时进度条

FS-10 显示总任务数、已完成、失败、速度 (files/s)、ETA；刷新周期 ≤ 200 ms；对非 TTY 环境（CI）自动退化为“每 1000 文件打印一次”模式；速度算法采用滑动窗口（最近 30 个任务），防止瞬时抖动；失败计数红色高亮，便于用户快速发现。

#### 4.3.2 日志分级

FS-11 支持 `-v`（info） `-vv`（debug）；日志同时写 console 与 `filego.log`；按大小轮转（10 MB），保留 7 份；每条日志含 RFC3339 时间、WorkerID、TaskID、文件路径、错误码；DEBUG 级别额外记录 Channel 长度、内存占用、系统 FD 数，方便排查泄漏。

### 4.4 CLI 接口

#### 4.4.1 参数解析

FS-12 必填参数缺失时给出示例并返回码 1；支持 `-h/--help`、`-v/--version`；未知参数给出“did you mean?”提示；布尔型标志支持 `--debug` 与 `--debug=true` 两种写法。

#### 4.4.2 子命令模式

FS-13 提供 copy | rename | md5 | prefix | suffix 五种子命令；各子命令独享参数集合，互不影响；子命令 help 自动列出专属示例（copy 示例见附录 A）。

#### 4.4.3 配置文件

FS-14 支持 `-c filego.toml` TOML 格式；命令行参数优先级高于文件；配置文件段 `[common]` `[copy]` `[md5]` 等可分别定义默认参数；启动时若配置文件解析失败，打印行号并立即退出。


## 5.非功能需求

### 5.1 性能

**响应时间**
10 MB 文件端到端 P95 ≤ 100 ms，1 MB 文件平均 ≤ 25 ms。
**并发能力**
Worker 1–100 可调，默认 CPU×2；100 Worker 下 CPU 约 85 %，堆内存 ≈ 200 MB。
**处理速度**
本地 NVMe 盘 10 k 文件总耗时 ≤ 30 s，较串行 cp 提速 ≥ 5 倍；网络盘自动降并发，仍保持带宽饱
### 5.2 可靠性

#### 错误隔离
单个 Task panic 由 defer recover() 捕获，仅标记该 Task 失败，Worker 继续消费下一 Task。
捕获后记录调用栈到日志，并在进度条对应文件行打红 ✗ 符号。

#### 5.2.1重试策略
可重试错误（I/O timeout、Permission denied）默认最多 3 次，指数退避 10 ms → 20 ms → 40 ms。
不可重试错误（file not found、MD5 mismatch）立即标记失败，不重试。

#### 5.2.2数据一致性
复制：先写入临时文件 <dst>.filego-tmp，成功后再 Rename()，保证原子性。
重命名：使用 os.Rename()，利用操作系统原子语义；跨卷时自动降级为“复制+校验+删除”三步事务。
MD5：计算与写入 <file>.md5 在同一 fsync() 周期完成，防止出现半写校验文件。

#### 5.2.3断点续作
提供 --resume 标志；程序在输出目录生成 .filego-manifest.json，记录已完成文件列表与 MD5。
重启时加载清单，跳过已完成 Task；清单每 100 个 Task 刷新一次，防止崩溃丢失。

#### 5.2.4日志与可追踪性
日志级别：ERROR/WARN/INFO/DEBUG，写入 filego-yyyy-mm-dd.log，默认保留 7 天，支持 –log-days N 调整。
每条日志包含：时间(毫秒)、级别、WorkerID、文件路径、错误码(errno)、消息 JSON 化，方便 ELK 收集。

### 5.3 易用性
#### 5.3.1命令行自解释
所有子命令提供 Examples 段落，给出 1–2 行最常见用例；-h 输出不超过 80 列，彩色高亮关键参数。
非法参数即时给出“Did you mean?”提示；返回码 1 同时 stderr 打印示例修正。

#### 5.3.2实时进度反馈
进度条固定底部，日志滚动上部；支持 –progress=none|bar|json 三种模式，JSON 模式供 CI 解析。
完成时打印摘要：
Copied 9 950 files (95.5 GB), skipped 30, failed 20, elapsed 28.3 s, 352 files/s

#### 5.3.3错误可视化
失败文件在进度条下方单独列表，红字显示相对路径+错误原因；超过 10 条时折叠，日志文件可查全量。
对于常见错误（权限、磁盘满）给出外部链接指向 FAQ。

### 5.4 可维护性
#### 5.4.1模块化约束
代码划分为 main、pool、operator、logger、cli 五包，包间禁止循环 import，通过 interface 定义依赖。
每个文件操作算法封装为 Operator 接口，新增操作仅需实现 Apply(ctx, task) error 即可插入 Worker 池。

#### 5.4.2编码规范
强制 gofmt + go vet + golangci-lint CI 门禁；函数复杂度 gocyclo ≤ 15。
公共函数注释率 100 %，遵循 Go doc 格式；示例代码放入 *_test.go 的 Example 函数。

### 5.5 安全性
#### 5.5.1零网络监听
默认不打开任何 TCP/UDP 端口；–pprof 仅在用户显式指定时开启，并绑定 127.0.0.1，禁止 0.0.0.0。

#### 5.5.2目录沙箱
使用 filepath.EvalSymlinks 解析软链接，默认 –safe-link=true，拒绝在目标路径跳出用户指定根目录；可通过 –unsafe-link 关闭检测。

#### 5.5.3文件权限继承
复制后的文件保持与原文件相同的 POSIX 权限位（Windows 下保持只写/只读属性）。

#### 5.5.4敏感信息规避
日志中不打印文件内容，仅记录路径、大小、MD5 摘要；对命令行参数中的密钥类字符串自动掩码（正则匹配）。

#### 5.5.5供应链安全
三方库仅引入 pb/v3 及其依赖，使用 go mod verify 校验哈希；发布时附带 go.sum 与 SBOM.json。

### 5.6 可移植性
#### 5.6.1跨平台编译
纯 Go 无 CGO，支持 GOOS=windows|linux|darwin GOARCH=amd64|arm64|386 一键构建；Makefile 提供 make all 生成三平台二进制。
#### 5.6.2体积与依赖
静态编译后原始大小 ≈ 12 MB；经 upx --best 压缩后 ≤ 8 MB，压缩耗时 < 3 s，启动耗时增加 < 10 ms。
#### 5.6.3运行时依赖
除操作系统内核外无其他运行时；不依赖 glibc 版本，可在 Alpine Linux (musl) 上直接运行。。
#### 5.6.4云原生适配
支持在 Kubernetes Job/CronJob 中运行，进度 JSON 输出可被 Fluent-bit 收集；退出码遵循 POSIX，方便 restartPolicy: OnFailure 重试。

## 6 数据需求
### 6.1 文件元数据
主进程启动后只在内存中维护三张轻量表：
**TaskQueue** ：由 Channel 自带缓冲，元素为 Task 结构，含源路径、目标路径、操作类型、已重试次数。
**ResultMap**：sync.Map，键为路径，值为状态（doing/done/fail）与完成时间戳，用于断点续作时快速过滤已完成项。
**ErrorSlice**：线程安全切片，追加失败记录，优雅退出时一次性落盘为 .filego-error.log，每条记录限 200 字符以内，防止爆炸增长。

### 6.2 日志数据
日志单行 JSON，字段固定：时间、级别、worker_id、路径、错误码、消息。
文件达到 10 MB 自动轮转，保留 7 天，历史文件 gzip 压缩后额外节省 70 % 空间。
Debug 级别下才打印堆栈，防止 I/O 放大。

### 6.3 配置数据
文件格式：TOML
段：[common] [copy] [md5] …
热加载：不支持，启动一次性读取。

## 7 外部接口需求

### 7.1 用户接口
**命令行**：以子命令 + 长/短标志方式交互，必填项缺失时即时给出“示例命令”并返回码 1；成功走完所有任务返回 0，任何不可恢复异常统一返回码 2，方便脚本 set -e 捕获。
**输入**：除了参数，还支持 -c filego.toml 配置文件与环境变量 FILEGO_WORKERS 做默认覆盖，优先级“CLI > 环境 > 配置”。
**输出**：屏幕上半部为分级日志，底部固定进度条；--output=json 可关闭所有 TUI，每完成一个任务输出一行 JSON，CI 可直接按行解析。

### 7.2 操作系统接口
**文件系统**：统一通过 os.ReadDir、os.Open 等 Go 封装调用，Linux/macOS 最终落到 POSIX 系统调用，Windows 则自动转调 Win32 API；不依赖 cgo，因此交叉编译后可在最小容器（scratch/alpine）运行。

**信号**：注册 signal.Notify 捕获 SIGINT/SIGTERM，收到信号后池内 Worker 完成当前任务即退出，主进程刷写断点清单并打印“interrupted, 95 % finished”摘要，返回码 130。

### 7.3 第三方库接口
**github.com/cheggaaa/pb/v3**：仅用于终端进度条渲染，MIT 授权；对其接口做薄封装，若未来需替换，只需改动 progress 包内两条函数即可。
**其余全部使用 Go 标准库**：文件遍历、缓冲读写、JSON/TOML 解析、哈希计算均不引入外部依赖，降低供应链风险与许可冲突。
## 8 运行与部署约束
### 8.1 硬件
**CPU**：x86-64 或 ARM64 架构，最低双核；工具并发度默认设为 runtime.NumCPU()×2，在 2 核机器上可自动降到 4 Worker，保证宿主机仍有余力响应其他进程。
**内存**：512 MB 即可启动，100 Worker 满载时堆峰值约 200 MB（含 2 MB 缓冲区/Worker + 进度条缓存）；若系统可用内存不足 256 MB，启动时会打印警告并建议降低并发。
**磁盘**：除待处理文件本身外，需预留总量 10 % 的额外空间用于临时文件（.filego-tmp）与日志；空间不足时工具会前置检查，立即报错并给出所需最小字节数，避免中途失败。

### 8.2 软件
**操作系统**：Windows 10 Build 19041+、Linux kernel 3.10+（glibc 2.17+ 或 musl 1.1+）、macOS 11 (Big Sur)+；在 WSL2、Docker Desktop、QEMU 用户态均测试通过。
**运行时**：开发需要 Go 1.23+；交付物为静态链接二进制，可拷贝到目标机直接运行，无运行时、无 JVM、无 .NET，不依赖系统 libstdc++。
### 8.3 部署方式
#### 8.3.1单二进制:
filego（Unix）或 filego.exe（Windows），chmod +x 即可；可把可执行文件放在 /usr/local/bin 或 %USERPROFILE%\bin，无需安装向导。

#### 8.3.2容器:
官方 Dockerfile 两阶段构建——第一阶段编译，第二阶段 FROM scratch，仅含二进制与 ca-certificates（便于下载更新），镜像 ≤ 15 MB；支持 docker run --rm -v /host:/data filego copy ... 一行命令完成批量处理。

#### 8.3.3 CI 集成：提供 GitHub Actions 工作流示例：
触发标签推送后，矩阵构建 linux/amd64、darwin/amd64、windows/amd64 三平台可执行文件；
自动 UPX 压缩、生成 SHA256 校验文件，创建 Release 并上传资产；
用户可在自己仓库 uses: filego/actions/release@v1 直接引用，实现“git tag → 二进制发布”一键流水线。

## 9 验收准则
### 9.1 AC-01 性能基准
准备 10 000 个普通文件，总大小 100 GB±5 %，存放于 NVMe SSD、4 核 8 GB 测试机。工具使用默认并发（8 Worker）完成“复制到空目录”任务，端到端耗时 ≤ 30 s；三次运行取几何平均，任何一次超标即视为不合格。

### 9.2 AC-02 可靠性基准
在同一文件集中随机挑选 5 % 文件，通过 chmod -w 注入只读错误。运行 copy 任务后：
a 工具自身崩溃次数 = 0；
b 成功复制的文件数 ≥ 9 900（即 99 %）；
c 失败列表与日志中的路径、错误码（EACCES/EPERM）完全一致，无重复、无遗漏。

### 9.3 AC-03 体积与交付
使用官方 Makefile 静态编译并执行 upx --best 后，单一可执行文件 ≤ 8 MB；file filego 输出应为 “statically linked”。超出字节数即视为不合格。

### 9.4 AC-04 测试质量
运行 go test ./... -race -coverprofile=c.out：
a 单元测试通过率 100 %，无 Race 警告；
b 总体代码覆盖率 ≥ 80 %，核心包（pool/operator）≥ 90 %；
c Benchmark 无负向退化，与基线相比波动 ≤ ±5 %。
以上四项全部通过，即判定该版本达到发布标准。